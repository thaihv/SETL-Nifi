<%@ page contentType="text/html" pageEncoding="UTF-8" session="false" %>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css" type="text/css"/>
<script type="text/javascript" src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/wicket/1.3.6/wicket.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/wicket/1.3.6/wicket-leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-loading@0.1.24/src/Control.Loading.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-loading@0.1.24/src/Control.Loading.css" type="text/css"/>
<div id="map" style="height: 800px; width:800px; position: relative; padding: 0px; margin: 0 auto 0 auto;"></div>

<script> 
	var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
	    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
	});
	var baseMaps = {
		    "OSM": osm
		};
	var geoType = "<%= request.getAttribute("geoType")%>";
	var crs = '<%= request.getAttribute("crs")%>';
	if (geoType == "Tiles"){
		
		var resourceUri = "<%= request.getAttribute("resourceUri")%>";
		var urlGeoTiles = resourceUri + "/{z}/{x}/{y}";
		var envelope    = <%= request.getAttribute("envelope")%>;
		var center      = <%= request.getAttribute("center")%>;
		var zoom_init   = <%= request.getAttribute("zoom_min")%>;
		var zoom_max    = <%= request.getAttribute("zoom_max")%>;
		
		
		var myTileBound;
	    var myTiles = new L.tileLayer(urlGeoTiles, {
	        minZoom: 1,
	        maxZoom: 20,
	        tms: false, // need check from server to get Tiles status 
	        attribution: 'Generated by Jungdo-SETL engine'
	      });
		myTiles.onAdd = function() {
			this._initContainer();

			this._levels = {};
			this._tiles = {};

			this._resetView();
			this._update();
			// For first step, store the tile 0,0 boundary to fit in
			myTileBound = this._tileCoordsToBounds(L.point({x: 0, y: 0, z: zoom_init}));
			
			
		}	    
	    
		var grid = new L.GridLayer();
		grid.createTile = function(coords) {
		  var tile = L.DomUtil.create('canvas', 'leaflet-tile');
		  var ctx = tile.getContext('2d');
		  var size = this.getTileSize()
		  tile.width = size.x
		  tile.height = size.y
		  
		  // calculate projection coordinates of top left tile pixel
		  var nwPoint = coords.scaleBy(size)
		  
		  // calculate geographic coordinates of top left tile pixel
		  var nw = map.unproject(nwPoint, coords.z)
		  ctx.fillStyle = 'white';
		  ctx.fillRect(0, 0, size.x, 50);
		  ctx.fillStyle = 'black';
		  ctx.fillText('x: ' + coords.x + ', y: ' + coords.y + ', zoom: ' + coords.z, 20, 20);
		  ctx.fillText('lat: ' + nw.lat + ', lon: ' + nw.lng, 20, 40);
		  ctx.strokeStyle = 'red';
		  ctx.beginPath();
		  ctx.moveTo(0, 0);
		  ctx.lineTo(size.x-1, 0);
		  ctx.lineTo(size.x-1, size.y-1);
		  ctx.lineTo(0, size.y-1);
		  ctx.closePath();
		  ctx.stroke();
		  return tile;
		}	    
	    // Geopackage always set XY tiles at 0,0 as upper left
	    // need upgrading for other geo tiles types
		var map = L.map('map', {    
			center: [90,180], 
		    zoom: zoom_init,
		    layers: [myTiles],
			loadingControl: true});
	    
		var baseMaps = {
				"myTiles": myTiles
			};	    
		var overlayMaps = {
				"Grid Cells":  grid
			};
		L.control.layers(baseMaps, overlayMaps).addTo(map);
		L.control.scale().addTo(map);
		
		// Fit in with the boundary of Tile 0,0, it should better select a center tile 
		// or calculate the boundary of whole a level to do that  
		map.fitBounds(myTileBound);
		
		map.on('click', function(e){
			  var coord = e.latlng;
			  var lat = coord.lat;
			  var lng = coord.lng;
			  var content = "You are at lat/lon: " + lat + "; " + lng;
			  var popup = L.popup().setLatLng(coord).setContent(content).openOn(map);
			  });	    
	}
	else{	
			var resourceUri = "<%= request.getAttribute("resourceUri")%>";
			var urlGeoTiles = resourceUri + "/{z}/{x}/{y}";
			var envelope    = <%= request.getAttribute("envelope")%>;
			var center      = <%= request.getAttribute("center")%>;
			
			var geocenter = [105.65287399291995,20.975032806396456];  // Ha Noi,  Vietnam as default location 
			if (center !== null)
				geocenter = proj4(crs,'EPSG:4326',center);
			
			var map = L.map('map', {    
				center: [geocenter[1],geocenter[0]],
			    zoom: 12,
			    layers: [osm],
				loadingControl: true});
			
			var bounds;
			if (envelope !== null){
				var corner1 = [envelope[0][0], envelope[1][0]];
				var corner2 = [envelope[0][1], envelope[1][1]];			
				corner1 = proj4(crs,'EPSG:4326',corner1);
				corner2 = proj4(crs,'EPSG:4326',corner2);	
				// Revert from X,Y to Y,X to get work with Leaflet
				corner1 = L.latLng(corner1[1], corner1[0]);
				corner2 = L.latLng(corner2[1], corner2[0]);				
				bounds  = L.latLngBounds(corner1, corner2);				
			}			
			
		    var myTiles = new L.tileLayer(urlGeoTiles, {
		        minZoom: 1,
		        maxZoom: 20,
		        tms: false, // need check from server to get Tiles status 
		        attribution: 'Generated by Jungdo-SETL engine'
		      });
				
			var grid = new L.GridLayer();
			grid.createTile = function(coords) {
			  var tile = L.DomUtil.create('canvas', 'leaflet-tile');
			  var ctx = tile.getContext('2d');
			  var size = this.getTileSize()
			  tile.width = size.x
			  tile.height = size.y
			  
			  // calculate projection coordinates of top left tile pixel
			  var nwPoint = coords.scaleBy(size)
			  // calculate projection coordinates of bottom right tile pixel
			  var sePoint = nwPoint.add(size);

			  // calculate geographic coordinates of top left tile pixel
			  var nw = map.unproject(nwPoint, coords.z)
			  // calculate geographic coordinates of bottom right tile pixel
			  var se = map.unproject(sePoint, coords.z);
			// calculate geographic coordinates of tile bound
			  var bounds = new L.LatLngBounds(nw, se);

			  
			  ctx.fillStyle = 'white';
			  ctx.fillRect(0, 0, size.x, 50);
			  ctx.fillStyle = 'black';
			  ctx.fillText('x: ' + coords.x + ', y: ' + coords.y + ', zoom: ' + coords.z, 20, 20);
			  ctx.fillText('lat: ' + nw.lat + ', lon: ' + nw.lng, 20, 40);
			  ctx.strokeStyle = 'red';
			  ctx.beginPath();
			  ctx.moveTo(0, 0);
			  ctx.lineTo(size.x-1, 0);
			  ctx.lineTo(size.x-1, size.y-1);
			  ctx.lineTo(0, size.y-1);
			  ctx.closePath();
			  ctx.stroke();
			  return tile;
			}
			var overlayMaps = {
					"myVecTiles": myTiles,
					"Grid Cells":  grid
				};			
			L.control.layers(baseMaps, overlayMaps).addTo(map);
			L.control.scale().addTo(map);	
			map.on('click', 
					function(e){
						var coord = e.latlng.toString().split(',');
						var lat = coord[0].split('(');
						var lng = coord[1].split(')');
						console.log("You clicked the map at latitude: " + lat[1] + " and longitude:" + lng[0]);
					});
			myTiles.addTo(map);
			if (bounds !== null)
				map.fitBounds(bounds);
	}
</script>